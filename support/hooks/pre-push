#!/usr/bin/env bash
#
# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local sha1> <remote ref> <remote sha1>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

DUMMY_SHA=0000000000000000000000000000000000000000

echo "Running pre-push check; to skip this step use 'push --no-verify'"

while read LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA
do
	if [ "$LOCAL_SHA" = $DUMMY_SHA ]
	then
		# Branch deleted. Do nothing.
		exit 0
	else
		if [ "$REMOTE_SHA" = $DUMMY_SHA ]
		then
			# New branch. Verify last 15 commits, since verification of the entire
			# history would take too much time.
			RANGE="$LOCAL_SHA~15..$LOCAL_SHA"
		else
			# Updating branch. Verify new commits.
			RANGE="$REMOTE_SHA..$LOCAL_SHA"
		fi

		# Verify DCO signoff. We do this before the format checker, since it has
		# some probability of failing spuriously, while this check never should.
		#
		# In general, we can't assume that the commits are signed off by author
		# pushing, so we settle for just checking that there is a signoff at all.
		SIGNED_OFF=$(git rev-list --grep "^Signed-off-by: " "$RANGE")
		NOT_SIGNED_OFF=$(git rev-list "$RANGE" | grep -Fxv "$SIGNED_OFF")
		if [ -n "$NOT_SIGNED_OFF" ]
		then
			echo >&2 "ERROR: The following commits do not have DCO signoff:"
			while read -r commit; do
				echo "  $(git log --pretty=oneline --abbrev-commit -n 1 $commit)"
			done <<< "$NOT_SIGNED_OFF"
			exit 1
		fi

		# NOTE: The `tools` directory will be the same relative to the support
		# directory, independent of whether we're in a submodule, so no need to use
		# our `relpath` helper.
		SCRIPT_DIR="$(dirname "$(realpath "$0")")/../../tools"

		# TODO(hausdorff): We should have a more graceful failure story when the
		# user does not have all the tools set up correctly. This script assumes
		# `$CLANG_FORMAT` and `$BUILDIFY` are defined, or that the default values it
		# assumes for these variables correspond to real binaries on the system. If
		# either of these things aren't true, the check fails.
		for i in $(git diff --name-only $RANGE --diff-filter=ACMR 2>&1); do
			echo "  Checking format for $i"
			"$SCRIPT_DIR"/check_format.py check $i
			if [[ $? -ne 0 ]]; then
				exit 1
			fi
		done
	fi
done

exit 0
